{"/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/test.js":"/* istanbul instrument in package npmtest_twitter_stream_channels */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/lib.npmtest_twitter_stream_channels.js":"/* istanbul instrument in package npmtest_twitter_stream_channels */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_twitter_stream_channels = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_twitter_stream_channels = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-twitter-stream-channels && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_twitter_stream_channels */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_twitter_stream_channels\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_twitter_stream_channels.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_twitter_stream_channels.rollup.js'] =\n            local.assetsDict['/assets.npmtest_twitter_stream_channels.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_twitter_stream_channels.__dirname + '/lib.npmtest_twitter_stream_channels.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/lib/TwitterStreamChannels.js":"/**\n * With the Twitter stream API, you can only open one stream at a time. So, if you have multiple filters, the tweets in result will be mixed up, you'll need to do some post-processing.\n * \n * This module lets you open multiple channels with there own filters, on the same stream. And then, you can add events to each of them individually, to listen to there results, like if you had open multiple streams.\n * \n * twitter-stream-channels handles all the post-processing, the connexion layer (OAuth, etc ...) is handled by [twit](https://github.com/ttezel/twit). See the [FAQ](https://github.com/topheman/twitter-stream-channels#faq) about both topics.\n * @module twitter-stream-channels\n * @main twitter-stream-channels\n */\n\nvar twit = require('twit');\nvar StreamChannels = require('./StreamChannels');\n\n/**\n * **This is your main point of entry to the whole module**.\n * \n * Manage filters on multiple channels on the same Twitter Stream\n * ```js\nvar TwitterStreamChannels = require('twitter-stream-channels');\nvar credentials = require('./my.twitter.credentials.json');\n\nvar client = new TwitterStreamChannels(credentials);\n\nvar channels = {\n\t\"languages\" : ['javascript','php','java','python','perl'],\n\t\"js-frameworks\" : ['angularjs','jquery','backbone','emberjs'],\n\t\"web\" : ['javascript','nodejs','html5','css','angularjs']\n};\n\nvar stream = client.streamChannels({track:channels});\n\nstream.on('channels/languages',function(tweet){\n    console.log('>languages',tweet.text);//any tweet with 'javascript','php','java','python','perl'\n});\n\nstream.on('channels/js-frameworks',function(tweet){\n    console.log('>frameworks',tweet.text);//any tweet with 'angularjs','jquery','backbone','emberjs'\n});\n\nstream.on('channels/web',function(tweet){\n    console.log('>web',tweet.text);//any tweet with 'javascript','nodejs','html5','css','angularjs'\n});\n\n//If you want, you can listen on all the channels and pickup the $channels added by the module\n//It contains the channel and the keywords picked up in the tweet\n//stream.on('channels',function(tweet){\n//    console.log(tweet.$channels,tweet.text);//any tweet with any of the keywords above\n//});\n\n//If you're really picky, you can listen to only some keywords\n//stream.on('keywords/javascript',function(tweet){\n//    console.log(tweet.text);//any tweet with the keyword \"javascript\"\n//});\n\nsetTimeout(function(){\n    stream.close();//closes the stream connected to Twitter\n\tconsole.log('>stream closed after 100 seconds');\n},100000);\n```\n * @class TwitterStreamChannels\n * @constructor\n * @param {Object} credentials\n * @param {String} credentials.consumer_key\n * @param {String} credentials.consumer_secret\n * @param {String} credentials.access_token\n * @param {String} credentials.access_token_secret\n * @return {TwitterStreamChannels}\n */\nvar TwitterStreamChannels = function(credentials) {\n  this.apiClient = new twit(credentials);\n};\n\n/**\n * Returns a mocked object of TwitterStreamChannels on which you will be able to play your scenarios offline with your own mocked tweets\n * @method getMockedClass\n * @static\n * @return {TwitterStreamChannelsMock}\n */\nTwitterStreamChannels.getMockedClass = function(){\n  return require('../mocks/TwitterStreamChannels');\n};\n\n/**\n * This will allow you to create your own json data mocks\n * \n * Keep in mind this class is not designed to retrieve lots of tweets on long duration.\n * \n * It was only designed to ease the creation of your data mocks to use after with `TwitterStreamChannels.getMockedClass()`\n * \n * More infos in the [README on the github repo](https://github.com/topheman/twitter-stream-channels#api)\n * @method launchMockDataRetriever\n * @static\n * @param {Object} credentials\n * @param {String} credentials.consumer_key\n * @param {String} credentials.consumer_secret\n * @param {String} credentials.access_token\n * @param {String} credentials.access_token_secret\n * @param {Object} options\n * @param {Array} options.track array of keywords to track\n * @param {String} options.output filepath of the json file where to put the retrieved tweets\n * @param {String} [options.maxNumber=200] maximum number of tweets that will be retrieved (default 200 / max 500)\n * @param {String} [options.timeout=100000] maximum delay after the stream will close whatever number of tweets are captured (default 100 000ms)\n * @return {MockDataRetriever}\n */\nTwitterStreamChannels.launchMockDataRetriever = function(credentials,options){\n  return new require('./MockDataRetriever')(credentials,options);\n};\n\n/**\n * Returns a Twitter API client on which you can do pretty much what you want.\n * More here https://github.com/ttezel/twit\n * @method getApiClient\n * @returns {twit}\n */\nTwitterStreamChannels.prototype.getApiClient = function() {\n  return this.apiClient;\n};\n\n/**\n * Opens a Twitter Stream and returns you an other one on which you'll be able to attach events for each channels\n * @method streamChannels\n * @param {Object} options You can use the same filter options as described in the Twitter stream API for `statuses/filter` https://dev.twitter.com/docs/api/1.1/post/statuses/filter\n * @param {Object|Array} options.track Pass an object describing your channels. If you don't want to use channels, you can pass directly an array of keywords.\n * @param {String} [options.follow] A comma separated list of user IDs, indicating the users to return statuses for in the stream\n * @param {String} [options.locations] Specifies a set of bounding boxes to track. More about how to format this parameter here : https://dev.twitter.com/docs/streaming-apis/parameters#locations\n * @param {Boolean} [options.enableChannelsEvents=true] If true, will fire the events like 'channels/channelName'\n * @param {Boolean} [options.enableRootChannelsEvent=true] If true, will fire the event 'channels'\n * @param {Boolean} [options.enableKeywordsEvents=false] If true, will fire the events 'keywords/keywordName' (disabled by default)\n * @return {StreamChannels}\n */\nTwitterStreamChannels.prototype.streamChannels = function(options) {\n  return new StreamChannels(this.apiClient, options);\n};\n\nmodule.exports = TwitterStreamChannels;","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/lib/StreamChannels.js":"/**\n * @module twitter-stream-channels\n */\nvar EventEmitter = require('events').EventEmitter,\n        util = require('util');\n\n/**\n * The constructor itself of this class is private, you should open a StreamChannels via {{#crossLink \"TwitterStreamChannels/streamChannels\"}}TwitterStreamChannels.streamChannels(options){{/crossLink}} \n * \n * Check out the available events in the [README on the github repo](https://github.com/topheman/twitter-stream-channels#faq).\n * @class StreamChannels\n * @constructor\n * @private\n * @extends events.EventEmitter\n * @param {twit} apiClient\n * @param {Object} options You can use the same filter options as described in the Twitter stream API for `statuses/filter` https://dev.twitter.com/docs/api/1.1/post/statuses/filter\n * @param {Object|Array} options.track Pass an object describing your channels. If you don't want to use channels, you can pass directly an array of keywords.\n * @param {String} [options.follow] A comma separated list of user IDs, indicating the users to return statuses for in the stream\n * @param {String} [options.locations] Specifies a set of bounding boxes to track. More about how to format this parameter here : https://dev.twitter.com/docs/streaming-apis/parameters#locations\n * @param {Boolean} [options.enableChannelsEvents=true] If true, will fire the events like 'channels/channelName'\n * @param {Boolean} [options.enableRootChannelsEvent=true] If true, will fire the event 'channels'\n * @param {Boolean} [options.enableKeywordsEvents=false] If true, will fire the events 'keywords/keywordName' (disabled by default)\n * @returns {StreamChannels}\n */\nvar StreamChannels = function(apiClient, options) {\n  helpers.checkStreamChannelsOptions(options, this);\n  options.enableChannelsEvents = typeof options.enableChannelsEvents === 'undefined' ? true : options.enableChannelsEvents;\n  options.enableRootChannelsEvent = typeof options.enableRootChannelsEvent === 'undefined' ? true : options.enableRootChannelsEvent;\n  options.enableKeywordsEvents = typeof options.enableKeywordsEvents === 'undefined' ? false : options.enableKeywordsEvents;\n  helpers.preprocessKeywords(options, this);\n  this.currentStream = apiClient.stream('statuses/filter',this._getOptionsToPassToApiClient(options));\n  EventEmitter.call(this);\n  addEvents(this.currentStream, this);\n  this.options = options;\n};\n\nutil.inherits(StreamChannels, EventEmitter);\n\n\nvar defaultEventsToTransmit = [\n  'connect',\n  'connected',\n  'disconnect',\n  'reconnect',\n  'warning'\n];\n\n/**\n * Adds the events (specifics and propagated from twitter API client), according to options\n * @function addGenericEvents\n * @private\n * @param {twit} twitterStream\n * @param {StreamChannels} streamChannels\n * @param {Object} [options]\n * @param {Boolean} [options.enableChannelsEvents=true] If true, will fire the events like 'channels/channelName'\n * @param {Boolean} [options.enableRootChannelsEvent=true] If true, will fire the event 'channels'\n * @param {Boolean} [options.enableKeywordsEvents=false] If true, will fire the events 'keywords/keywordName' (disabled by default)\n * @returns {streamChannels}\n */\nvar addEvents = function(twitterStream, streamChannels){\n  //transmit events\n  for(var i=0; i<defaultEventsToTransmit.length; i++){\n    (function(eventName){\n      twitterStream.on(eventName,function(msg){\n        streamChannels.emit(eventName, msg);\n      });\n    })(defaultEventsToTransmit[i]);\n  }\n  twitterStream.on('tweet',function(msg){\n    helpers.onTweetEvent(msg, streamChannels);\n  });\n  return streamChannels;\n};\n\n/**\n * Removes the events (specifics and propagated from twitter API client), according to options\n * @function removeEvents\n * @private\n * @param {twit} twitterStream\n * @param {StreamChannels} streamChannels\n * @param {Object} [options]\n * @param {Object} [options.removeAllListeners=false] If true removes all the listeners set on the stream\n * @returns {streamChannels}\n */\nvar removeEvents = function(twitterStream, streamChannels, options){\n  if(options.removeAllListeners === true){\n    streamChannels.removeAllListeners();\n  }\n  return streamChannels;  \n};\n\n/**\n * Formats options passed with non-duplicate tracked keywords\n * @method _getOptionsToPassToApiClient\n * @private\n * @param {Object} options\n * @returns {Object}\n */\nStreamChannels.prototype._getOptionsToPassToApiClient = function(options){\n  var result = {};\n  var dontHandle = ['track','enableChannelsEvents','enableRootChannelsEvent','enableKeywordsEvents'];\n  if(typeof options !== 'undefined'){\n    for(var key in options){\n      if(dontHandle.indexOf(key) === -1){\n        result[key] = options[key];\n      }\n    }\n  }\n  result.track = this.trackedKeywords;\n  return result;\n};\n\n/**\n * Call this function to restart the stream after you called `.stop()` on it.\n * \n * Note: there is no need to call `.start()` to begin streaming. ` TwitterStreamChannels.streamChannels` calls .start() for you.\n * @method start\n * @returns {StreamChannels}\n */\nStreamChannels.prototype.start = function() {\n  this.currentStream.start();\n  return this;\n};\n\n/**\n * Closes the opened stream with Twitter\n * @method stop\n * @param {Object} [options]\n * @param {Object} [options.removeAllListeners=false] If true removes all the listeners set on the stream\n * @returns {StreamChannels}\n */\nStreamChannels.prototype.stop = function(options) {\n  options = typeof options === 'undefined' ? {} : options;\n  options.removeAllListeners = typeof options.removeAllListeners === 'undefined' ? false : options.removeAllListeners;\n  this.currentStream.stop();\n  removeEvents(this.currentStream, this, options);\n  return this;\n};\n\n/**\n * Returns your channel description\n * @method getChannels\n * @returns {StreamChannels.channels}\n */\nStreamChannels.prototype.getChannels = function() {\n  return this.channels;\n};\n\n/**\n * Returns an array of the keywords you're tracking (duplicates were removed)\n * @method getTrackedKeywords\n * @returns {Array}\n */\nStreamChannels.prototype.getTrackedKeywords = function() {\n  return this.trackedKeywords;\n};\n\n/**\n * Returns an object key/value - key:your channels - value:the full text search RegExp for the keywords of this channel\n * @method getchannelsKeywordsLowerCasedRegExp\n * @returns {StreamChannels.channels}\n */\nStreamChannels.prototype.getChannelsKeywordsLowerCasedRegExp = function() {\n  return this.channelsKeywordsLowerCasedRegExp;\n};\n\n/**\n * Removes all the listeners added\n * \n * See more methods http://nodejs.org/api/events.html#events_events\n * @method removeAllListeners\n * @param {String} event\n * @returns {StreamChannels}\n */\n\nmodule.exports = StreamChannels;\n\n/*\n * This class is private to the StreamChannels class, it's not exposed\n * @private\n * @class StreamChannels.helpers\n */\nvar helpers = {\n  /*\n   * Checks the options parameter for consistency and mandatory parameters\n   * @method checkStreamChannelsOptions\n   * @private\n   * @throws {Error}\n   * @param {Object} options\n   * @returns {undefined}\n   */\n  checkStreamChannelsOptions: function(options) {\n    if (typeof options === 'undefined') {\n      throw new Error('new StreamChannels(options) - options parameter missing');\n    }\n    else if (typeof options.track === 'undefined') {\n      throw new Error('new StreamChannels(options) - options.track parameter missing');\n    }\n    else if (!(typeof options.track === 'object' || typeof options.track === 'string')) {\n      throw new Error('new StreamChannels(options) - options.track must be an Object (representing your channels with there keywords), an Array (of keywords) or a String (with comma separeted keywords)');\n    }\n  },\n  /*\n   * Prepares the channels and keywords to be processed later\n   * @method preprocessKeywords\n   * @private\n   * @param {type} options\n   * @param {type} streamChannels\n   * @returns {StreamChannels}\n   */\n  preprocessKeywords: function(options, streamChannels) {\n    streamChannels.trackedKeywords = [];\n    streamChannels.channels = {};\n    streamChannels.channelsKeywordsLowerCased = {};\n    streamChannels.channelsKeywordsLowerCasedRegExpSafe = {};\n    streamChannels.channelsKeywordsLowerCasedRegExp = {};\n\n    if (options.track instanceof Array || typeof options.track === 'string') {\n      options.track = {\n        \"default\": options.track\n      };\n    }\n\n    for (var channel in options.track) {\n      streamChannels.channels[channel] = keywordsToArray(options.track[channel], []);//process the options.track[channel] to make sure it will be an array of keywords\n      streamChannels.channelsKeywordsLowerCased[channel] = streamChannels.channels[channel].map(function(item){\n        return item.toLowerCase();\n      });\n      streamChannels.channelsKeywordsLowerCasedRegExpSafe[channel] = streamChannels.channelsKeywordsLowerCased[channel].map(function(item){\n        return regExpEscape(item);//escape the lower cased keywords so they will be regexp proof\n      });\n      streamChannels.channelsKeywordsLowerCasedRegExp[channel] = streamChannels.channelsKeywordsLowerCased[channel].length > 0 ? new RegExp(streamChannels.channelsKeywordsLowerCasedRegExpSafe[channel].join('|'),'g') : null;//create the full text search regexp on lower cased keywords\n      streamChannels.channels[channel].forEach(function(item){\n        if(streamChannels.trackedKeywords.indexOf(item) === -1){\n          streamChannels.trackedKeywords.push(item);\n        }\n      });\n    }\n\n    /*\n     * Prepares keywords to an array of keywords like 'foo,bar' -> ['foo','bar'] also ['foo,bar','toto'] -> ['foo','bar','toto'] also 'foo,bar,toto' -> ['foo','bar','toto']\n     * @param {Array|String} keywords\n     * @returns {Array}\n     */\n    function keywordsToArray(keywords, result) {\n      if (typeof keywords === 'string') {\n        result = result.concat(keywords.split(','));\n      }\n      else if (keywords instanceof Array) {\n        if (keywords.length > 0) {\n          for (var i = 0; i < keywords.length; i++) {\n            result = keywordsToArray(keywords[i], result);\n          }\n        }\n      }\n      return result;\n    }\n\n    return streamChannels;\n  },\n  /*\n   * Tags $channels with an array of lower cased keywords found in it\n   * @param {Object} tweet The tweet to postprocess\n   * @param {StreamChannels} streamChannels The StreamChannels object we're on, to know which keywords and channels to process\n   * @returns {StreamChannels} tweetInfos Containing two arrays : channels and keywords found in the tweet\n   */ \n  postprocessTweet: function(tweet,streamChannels){\n    tweet.$channels = {};\n    tweet.$keywords = [];\n    var i,j,k;\n    var lowerCasedSearch = [];\n    var keywordsFound = [], tmpKeywords;\n    \n    //prepare the lowerCased strings to full text search in the tweet object\n    lowerCasedSearch.push(tweet.text.toLowerCase());\n    if(tweet.user && tweet.user.screen_name){\n      lowerCasedSearch.push(tweet.user.screen_name.toLowerCase());\n    }\n    if(tweet.entities && tweet.entities.urls && tweet.entities.urls.length > 0){\n      for(i=0; i<tweet.entities.urls.length; i++){\n        if(tweet.entities.urls[i].display_url){\n          lowerCasedSearch.push(tweet.entities.urls[i].display_url.toLowerCase());\n        }\n        if(tweet.entities.urls[i].expanded_url){\n          lowerCasedSearch.push(tweet.entities.urls[i].expanded_url.toLowerCase());\n        }\n      }\n    }\n    \n    //find the keywords\n    for(var channel in streamChannels.channelsKeywordsLowerCasedRegExp){\n      keywordsFound = [];\n      for(j=0; j<lowerCasedSearch.length; j++){\n        tmpKeywords = lowerCasedSearch[j].match(streamChannels.channelsKeywordsLowerCasedRegExp[channel]);\n        if(tmpKeywords !== null){\n          keywordsFound = keywordsFound.concat(tmpKeywords);\n        }\n      }\n      if(keywordsFound.length > 0){\n        tweet.$channels[channel] = [];\n        for(k=0; k<keywordsFound.length; k++){\n          if(tweet.$channels[channel].indexOf(keywordsFound[k]) === -1){\n            tweet.$channels[channel].push(keywordsFound[k]);\n          }\n          if(tweet.$keywords.indexOf(keywordsFound[k]) === -1){\n            tweet.$keywords.push(keywordsFound[k]);\n          }\n        }\n      }\n    }\n    return streamChannels;\n  },\n  /*\n   * Emits the tweet on the right events (according to the options passed by the user)\n   * @param {Object} tweet postprocessed tweet\n   * @param {type} streamChannels The StreamChannels object we're on, to emit from\n   * @returns {StreamChannels} returns the streamChannels object\n   */\n  emitPosprocessedTweet: function(tweet,streamChannels){\n    var channel, keyword;\n    if(streamChannels.options.enableRootChannelsEvent === true){\n      streamChannels.emit('channels', tweet);\n    }\n    if(streamChannels.options.enableChannelsEvents === true){\n      for(channel in tweet.$channels){\n        streamChannels.emit('channels/'+channel, tweet);\n      }\n    }\n    if(streamChannels.options.enableKeywordsEvents === true){\n      for(channel in tweet.$channels){\n        if(tweet.$channels[channel].length > 0){\n          for(var i=0; i<tweet.$channels[channel].length; i++){\n            streamChannels.emit('keywords/'+tweet.$channels[channel][i], tweet);\n          }\n        }\n      }\n    }\n    return streamChannels;\n  },\n  /*\n   * To execute when a tweet is received :\n   * - to posprocess the tweet\n   * - then emit the postprocessed tweet on the proper events\n   * @param {Object} tweet\n   * @param {StreamChannels} streamChannels\n   * @returns {StreamChannels}\n   */\n  onTweetEvent: function(tweet, streamChannels){\n    helpers.postprocessTweet(tweet, streamChannels);\n    return helpers.emitPosprocessedTweet(tweet, streamChannels);\n  }\n};\n\n/**\n * From http://docs.closure-library.googlecode.com/git/local_closure_goog_string_string.js.source.html#line1015\n * Escapes characters in the string that are not safe to use in a RegExp.\n * @param {*} s The string to escape. If not a string, it will be casted\n *     to one.\n * @return {string} A RegExp safe, escaped copy of {@code s}.\n */\nvar regExpEscape = function(s) {\n  return String(s).replace(/([-()\\[\\]{}+?*.$\\^|,:#<!\\\\])/g, '\\\\$1').\n      replace(/\\x08/g, '\\\\x08');\n};","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/main.js":"module.exports = require('./lib/TwitterStreamChannels');","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/lib/MockDataRetriever.js":"/**\n * @module twitter-stream-channels\n */\n\nvar twit = require('twit');\nvar fs = require('fs');\n\n/**\n * This contructor is private, you should access it via {{#crossLink \"TwitterStreamChannels/launchMockDataRetriever\"}}TwitterStreamChannels.launchMockDataRetriever(credentials,options){{/crossLink}}\n * \n * This will allow you to create your own json data mocks\n * \n * Keep in mind this class is not designed to retrieve lots of tweets on long duration.\n * \n * It was only designed to ease the creation of your data mocks to use after with `TwitterStreamChannels.getMockedClass()`\n * \n * More infos in the [README on the github repo](https://github.com/topheman/twitter-stream-channels#api)\n * @class MockDataRetriever\n * @constructor\n * @private\n * @param {Object} credentials\n * @param {String} credentials.consumer_key\n * @param {String} credentials.consumer_secret\n * @param {String} credentials.access_token\n * @param {String} credentials.access_token_secret\n * @param {Object} options\n * @param {Array} options.track array of keywords to track\n * @param {String} options.output filepath of the json file where to put the retrieved tweets\n * @param {String} [options.maxNumber=200] maximum number of tweets that will be retrieved (default 200 / max 500)\n * @param {String} [options.timeout=100000] maximum delay after the stream will close whatever number of tweets are captured (default 100 000ms)\n * @return {MockDataRetriever}\n */\nvar MockDataRetriever = function(credentials,options){\n  if(typeof options === 'undefined'){\n    throw new Error(\"options parameter is mandatory\");\n  }\n  if(typeof options.track === 'undefined'){\n    throw new Error(\"options.track parameter is mandatory\");\n  }\n  if(options.track instanceof Array !== true){\n    throw new Error(\"options.track parameter must be an array of keywords\");\n  }\n  if(options.output === 'undefined'){\n    throw new Error(\"options.output parameter is mandatory\");\n  }\n  if(typeof options.maxNumber === 'undefined'){\n    options.maxNumber = 200;\n  }\n  if(options.maxNumber > 500){\n    options.maxNumber = 500;\n  }\n  if(typeof options.timeout === 'undefined' || options.timeout > 100000){\n    options.timeout = 100000;\n  }\n  \n  var date = new Date();\n  \n  var client = new twit(credentials);\n  \n  var tweets = [];\n  \n  var stream = client.stream('statuses/filter', {track: options.track});\n  \n  var onEnd = function() {\n    stream.stop();\n    console.log('');\n    console.log('> stopped stream after '+( (new Date()).getTime() - date.getTime() )+'ms - '+tweets.length+' tweets retrieved');\n    if(tweets.length > 0){\n    tweets = JSON.stringify(tweets);\n      fs.writeFile(options.output,tweets,function(err,data){\n        console.log('> writing retrieved tweets into file : '+options.output);\n        if(err){\n          console.log('> ! an error occured while writing tweets to file');\n        }\n        process.exit();\n      });\n    }\n    else{\n      console.log('> ! no tweets retrieved, not writing into file : '+options.output);\n      process.exit();\n    }\n  };\n  \n  stream.on('connect', function() {\n    console.log('> connecting to twitter');\n  });\n  \n  stream.on('connected', function() {\n    console.log('> connected to twitter - will disconnect in '+options.timeout+'ms or when '+options.maxNumber+' tweets are retrieved');\n  });\n\n  stream.on('disconnect', function() {\n    console.log('> disconnected from twitter - please retry');\n  });\n  \n  stream.on('tweet', function(tweet) {\n    tweets.push(tweet);\n    process.stdout.clearLine();  // clear current text\n    process.stdout.cursorTo(0);  // move cursor to beginning of line\n    process.stdout.write(tweets.length+' tweets retrieved');  // write text\n    if(tweets.length >= options.maxNumber){\n      onEnd();\n    }\n  });\n\n  setTimeout(function() {\n    onEnd();\n  }, options.timeout);\n  \n};\n\nmodule.exports = MockDataRetriever;\n","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/spec/debug.js":"/*\n * The purpose of this file is to check if the Mockups behave correctly\n */\n\nvar TwitterStreamChannels = require('../../main').getMockedClass();\nvar client = new TwitterStreamChannels({});\nvar inputTweetsMocks = require('../mocks/data/tweets.json');\n\n//var stream = client.streamChannels({track: \"whatever is in the json mock file\"});\nvar stream = client.getApiClient().stream('statuses/filter',{track: \"whatever is in the json mock file\"});\nvar count = 0;\n\nstream.on('connect',function(){\n  console.log('> attempt connecting');\n});\n\nstream.on('connected',function(){\n  console.log('> connected');\n});\n\nstream.on('tweet',function(tweet){\n  console.log(tweet.text);\n  count++;\n});\n\nsetTimeout(function(){\n  stream.stop();\n  console.log('> stopped stream');\n  console.log('> retrieved '+count+' tweets / '+inputTweetsMocks.length+' tweets were send by the mock');\n  process.exit();\n},17000);","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/spec/offline/stream.events-spec.js":"/* \n/*\n * This test is offline - no calls is made to Twitter either by oAuth nor by stream\n * (so you can run it as many times as you want)\n */\n\nvar TwitterStreamChannels = require('../../main').getMockedClass();\nvar client = new TwitterStreamChannels({});\nvar channelsInput = {\n  \"colors\": ['blue', 'white', 'yellow', 'green', 'orange'],\n  \"fruits\": ['kiwi', 'orange,apple', 'lemon', 'coconut'],\n  \"starWarsCharacters\": ['Luke', 'Leia', 'Han', 'Yoda']\n};\n\ndescribe('client.streamChannels(options) - events (offline)',function(){\n  \n  //specific matchers\n  beforeEach(function() {\n    var matchers = {\n      toBeGreaterThanOrEqualTo: function(a) {\n        return this.actual >= a;\n      }\n    };\n    this.addMatchers(matchers);\n  });\n\n  describe(\"> .on('channels')\",function(){\n    \n    var trappedTweets;\n    var stream;\n  \n    beforeEach(function(){\n      \n      runs(function(){\n        trappedTweets = [];\n        stream = client.streamChannels({track: channelsInput});\n\n        stream.on('channels',function(tweet){\n          trappedTweets.push(tweet);\n        });\n      });\n\n      waitsFor(function(){\n        if(trappedTweets.length >= 10){\n          stream.stop();\n          return true;\n        }\n      },\"should have trapped 10 tweets\",10000);\n      \n    });\n    \n    it('should have trapped at least 10 tweets via the callback on the event',function(){\n      expect(trappedTweets.length).toBeGreaterThanOrEqualTo(10);\n    });\n    \n    it('should have trapped tweets with $channels',function(){\n      expect(trappedTweets[0].$channels).toBeDefined();\n      expect(trappedTweets[9].$channels).toBeDefined();\n    });\n    \n    it('$channels should have correct keywords in it',function(){\n      expect(trappedTweets[0].$channels['colors']).toEqual(['green']);\n      expect(trappedTweets[9].$channels['fruits']).toEqual(['apple']);\n    });\n    \n    it('should have trapped tweets with $keywords',function(){\n      expect(trappedTweets[0].$keywords).toBeDefined();\n      expect(trappedTweets[9].$keywords).toBeDefined();\n    });\n    \n    it('$keywords should have correct keywords in it',function(){\n      expect(trappedTweets[0].$keywords).toEqual(['green']);\n      expect(trappedTweets[9].$keywords).toEqual(['apple']);\n    });\n    \n  });\n\n  describe(\"> .on('channels/fruits')\",function(){\n    \n    var trappedTweets;\n    var stream;\n  \n    beforeEach(function(){\n      \n      runs(function(){\n        //no need to reinstantiate the stream for each \"it\", only the first (they all use the same tests results)\n        trappedTweets = [];\n        stream = client.streamChannels({track: channelsInput});\n\n        stream.on('channels/fruits',function(tweet){\n          trappedTweets.push(tweet);\n        });\n      });\n\n      waitsFor(function(){\n        if(trappedTweets.length >= 10){\n          stream.stop();\n          return true;\n        }\n      },\"should have trapped 10 tweets\",10000);\n      \n    });\n    \n    it('should have trapped at least 10 tweets via the callback on the event',function(){\n      expect(trappedTweets.length).toBeGreaterThanOrEqualTo(10);\n    });\n    \n    it('should have trapped tweets with $channels',function(){\n      expect(trappedTweets[0].$channels).toBeDefined();\n      expect(trappedTweets[9].$channels).toBeDefined();\n    });\n    \n    it('$channels should have correct keywords in it',function(){\n      expect(trappedTweets[0].$channels['fruits']).toEqual(['apple']);\n      expect(trappedTweets[9].$channels['fruits']).toEqual(['apple']);\n    });\n    \n  });\n\n  describe(\"> .on('keywords/orange')\",function(){\n    \n    var trappedTweets;\n    var stream;\n  \n    beforeEach(function(){\n      \n      runs(function(){\n        trappedTweets = [];\n        stream = client.streamChannels({\n          track: channelsInput,\n          enableChannelsEvents:false,\n          enableRootChannelsEvent:false,\n          enableKeywordsEvents:true\n        });\n\n        stream.on('keywords/orange',function(tweet){\n          trappedTweets.push(tweet);\n        });\n      });\n\n      waitsFor(function(){\n        if(trappedTweets.length >= 10){\n          stream.stop();\n          return true;\n        }\n      },\"should have trapped 10 tweets\",10000);\n      \n    });\n    \n    it('should have trapped at least 10 tweets via the callback on the event',function(){\n      expect(trappedTweets.length).toBeGreaterThanOrEqualTo(10);\n    });\n    \n    it('should have trapped tweets with $channels',function(){\n      expect(trappedTweets[0].$channels).toBeDefined();\n      expect(trappedTweets[9].$channels).toBeDefined();\n    });\n    \n    it('$channels should have correct keywords in it',function(){\n      expect(trappedTweets[0].$channels['colors']).toEqual(['orange']);\n      expect(trappedTweets[9].$channels['colors']).toEqual(['orange']);\n      expect(trappedTweets[0].$channels['fruits']).toEqual(['orange']);\n      expect(trappedTweets[9].$channels['fruits']).toEqual(['orange']);\n    });\n    \n  });\n  \n});","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/mocks/TwitterStreamChannels.js":"/**\n * @module twitter-stream-channels\n */\n\n/*\n * This is a very simple mock of TwitterStreamChannels for offline test purposes\n * To test only the init of the StreamChannels object (before any call to twitter)\n */\n\n//in unitTest, we pass a flag --config highSpeed true and then the events will be emitted really faster (not using setTimeout but process.nextTick)\nvar highSpeed = process.env.highSpeed ? true : false;\n\nvar StreamChannels = require('../lib/StreamChannels');\nvar fs = require('fs');\nvar EventEmitter = require('events').EventEmitter,\n        util = require('util');\n\n//optimization for the unit-tests\nvar nextLoop = (function(){\n  if(highSpeed === true){\n    return process.nextTick;\n  }\n  else{\n    return setTimeout;\n  }\n})();\n\n/*\n * Mock for the twitter api client twit\n * No oAuth request will be made\n * @param {Object} [credentials] @optional (since it's a mock, no credentials needed\n * @param {Array} [credentials.tweets] @optional (by default will load `/mocks/data/tweets.json`)\n * @param {Boolean} [credentials.singleRun=true] @optional if false will loop on the tweets mock array until you call stop (default true)\n * @param {Number} [credentials.tweetDelay=100] @optional delay between each tweets emitted in ms (default 100ms)\n */\nvar TwitMock = function(credentials){\n  //this is internal to the mock to give option to the dev to change the tweet mocks\n  credentials = typeof credentials === 'undefined' ? {} : credentials;\n  credentials.tweets = typeof credentials.tweets === 'undefined' ? require('./data/tweets.json') : credentials.tweets;\n  credentials.singleRun = typeof credentials.singleRun === 'undefined' ? true : credentials.singleRun;\n  credentials.tweetDelay = typeof credentials.tweetDelay === 'undefined' ? 100 : credentials.tweetDelay;\n  this._tweetsMock = credentials.tweets;\n  this._singleRun = credentials.singleRun;\n  this._tweetDelay = credentials.tweetDelay;\n};\n\n/*\n * Mocking .stream with an empty function so that no call will be made\n */\nTwitMock.prototype.stream = function(path, params){\n  return (new TwitStreamMock({\n    tweets:this._tweetsMock,\n    singleRun: this._singleRun,\n    tweetDelay: this._tweetDelay\n  })).start();\n};\n\n/*\n * Mock for the OAuth / stream part (no need to mock all the underlying methods, only the events part)\n * Emits :\n * - connect\n * - connected\n * - tweet : will read the inputTweetsMocks file and emit the tweet found inside\n * @param {Object} [options] @optional (since it's a mock, no credentials needed\n * @param {File} [options.tweets] @optional (by default will load `/mocks/data/tweets.json`)\n * @param {Boolean} [options.singleRun=true] @optional if false will loop on the tweets mock array until you call stop (default true)\n * @param {Number} [options.tweetDelay=100] @optional delay between each tweets emitted in ms (default 100ms)\n */\nvar TwitStreamMock = function(options){\n  \n  options = typeof options === 'undefined' ? {} : options;\n  options.tweets = typeof options.tweets === 'undefined' ? require('./data/tweets.json') : options.tweets;\n  options.singleRun = typeof options.singleRun === 'undefined' ? true : options.singleRun;\n  options.tweetDelay = typeof options.tweetDelay === 'undefined' ? 100 : options.tweetDelay;\n  \n  this.currentTweetIndex = 0;\n\n  EventEmitter.call(this);\n  \n  //following method are directly attached (on the prototype, they would be erased by EventEmitter's prototype)\n  this.start = function(){\n    \n    //don't do anything if already connected\n    if(this.abortedBy === null){\n      return this;\n    }\n    \n    var that = this;\n    this.abortedBy = null;\n  \n    var emitTweetCb = function(){\n      var that = this;\n      nextLoop(function(){\n        //only send tweet if the stream hasn't been stopped\n        if(that.abortedBy === null){\n          //emit the tweet\n          if(options.tweets[that.currentTweetIndex]){\n            options.tweets[that.currentTweetIndex].$index = that.currentTweetIndex;\n            that.emit('tweet',options.tweets[that.currentTweetIndex]);\n            that.currentTweetIndex++;\n          }\n          //case we are at the end of the tweets\n          if(that.currentTweetIndex >= options.tweets.length){\n            //in singleRun restart from 0\n            if(options.singleRun === false){\n              that.currentTweetIndex = 0;\n            }\n            else{\n              that._twitterDisconnect();\n              return false;//dont recall the callback for the next tick\n            }\n          }\n          emitTweetCb.call(that);\n        }\n      },1*options.tweetDelay);\n    };\n    \n    nextLoop(function(){\n      that.emit('connect');\n    },0);\n    nextLoop(function(){\n      that.emit('connected');\n    },1*options.tweetDelay);\n    nextLoop(function(){\n      emitTweetCb.call(that);\n    },2*options.tweetDelay);\n    \n    return this;\n  };\n  \n  this.stop = function(){\n    this.abortedBy = 'twit-client';\n    return this;\n  };\n  \n  this._twitterDisconnect = function(){\n    this.abortedBy = 'twitter';\n    this.emit('disconnect');\n    return this;\n  };\n  \n};\n\nutil.inherits(TwitStreamMock, EventEmitter);\n\n/**\n * This class mocks {{#crossLink \"TwitterStreamChannels\"}}TwitterStreamChannels{{/crossLink}} so that you could work offline, on your own data, without connecting to Twitter.\n * \n * See the examples on [the github repo](https://github.com/topheman/twitter-stream-channels/tree/master/examples)\n * @class TwitterStreamChannelsMock\n * @constructor\n * @param {Object} [options] @optional (since it's a mock, no credentials needed\n * @param {File} [options.tweets] @optional (by default will load `/mocks/data/tweets.json`)\n * @param {Boolean} [options.singleRun=true] @optional if false will loop on the tweets mock array until you call stop (default true)\n * @param {Number} [options.tweetDelay=100] @optional delay between each tweets emitted in ms (default 100ms)\n * @returns {TwitterStreamChannelsMock}\n */\nvar TwitterStreamChannelsMock = function(credentials){\n  this.apiClient = new TwitMock(credentials);\n};\n\n/**\n * Returns a mocked version of apiClient, only the .stream() method is mocked (will stream exactly the same tweets as {{#crossLink \"TwitterStreamChannelsMock/streamChannels\"}}stream.streamChannels(){{/crossLink}})\n * @method getApiClient\n * @returns {TwitMock}\n */\nTwitterStreamChannelsMock.prototype.getApiClient = function(){\n  return this.apiClient;\n};\n\n/**\n * Mocks the {{#crossLink \"TwitterStreamChannels/streamChannels\"}}TwitterStreamChannels.streamChannels(options){{/crossLink}} method of TwitterStreamChannels to return a StreamChannels object\n * \n * Will start to emit the tweets you specified in the tweets attributes in the constructor.\n * @method streamChannels\n * @param {Object} options\n * @param {Object|Array} options.track Pass an object describing your channels. If you don't want to use channels, you can pass directly an array of keywords.\n * @param {Boolean} [options.enableChannelsEvents=true] If true, will fire the events like 'channels/channelName'\n * @param {Boolean} [options.enableRootChannelsEvent=true] If true, will fire the event 'channels'\n * @param {Boolean} [options.enableKeywordsEvents=false] If true, will fire the events 'keywords/keywordName' (disabled by default)\n * @return {StreamChannels}\n */\nTwitterStreamChannelsMock.prototype.streamChannels = function(options){\n  return new StreamChannels(this.apiClient, options);\n};\n\nmodule.exports = TwitterStreamChannelsMock;","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/spec/offline/stream.init-spec.js":"/*\n * This test is offline - no calls is made to Twitter either by oAuth nor by stream\n * (so you can run it as many times as you want)\n */\n\nvar TwitterStreamChannels = require('../../main').getMockedClass();\nvar client = new TwitterStreamChannels({});\n\ndescribe('client.streamChannels(options) - init (offline)', function() {\n\n  describe('> options checking (exceptions handling)', function() {\n\n    it('should throw exceptions when passing no parameters in options', function() {\n      var error = null;\n      try {\n        var stream = client.streamChannels();\n        stream.stop();\n      }\n      catch (e) {\n        error = e.message;\n      }\n      finally {\n        expect(error).not.toBeNull();\n      }\n    });\n\n    it('should throw exceptions when track parameter is missing', function() {\n      var error = null;\n      try {\n        var stream = client.streamChannels({});\n        stream.stop();\n      }\n      catch (e) {\n        error = e.message;\n      }\n      finally {\n        expect(error).not.toBeNull();\n      }\n    });\n\n    it('should throw exceptions when track parameter is not an object(or an array) or a string', function() {\n      var error = null;\n      try {\n        var stream = client.streamChannels({track: 12});\n        stream.stop();\n      }\n      catch (e) {\n        error = e.message;\n      }\n      finally {\n        expect(error).not.toBeNull();\n      }\n    });\n\n    it('should NOT throw exceptions when track parameter is a string', function() {\n      var error = null;\n      try {\n        var stream = client.streamChannels({track: \"whatever\"});\n        stream.stop();\n      }\n      catch (e) {\n        error = e.message;\n      }\n      finally {\n        expect(error).toBeNull();\n      }\n    });\n\n  });\n\n  describe('> options reformating', function() {\n\n    var stringFiltersInput = \"blue,white,yellow,green,orange\";\n    var arrayFiltersInput = ['blue,white', 'yellow', 'green', 'orange'];\n    var arrayFiltersOutput = ['blue', 'white', 'yellow', 'green', 'orange'];\n    var channelsInput = {\n      \"colors\": stringFiltersInput,\n      \"fruits\": ['kiwi', 'orange,apple', 'lemon', 'coconut'],\n      \"starWarsCharacters\": ['Luke', 'Leia,Han', 'Yoda']\n    };\n    var channelsOuput = {\n      \"colors\": arrayFiltersOutput,\n      \"fruits\": ['kiwi', 'orange', 'apple', 'lemon', 'coconut'],\n      \"starWarsCharacters\": ['Luke', 'Leia', 'Han', 'Yoda']\n    };\n    var channelsKeywordsLowerCasedOuput = {\n      \"colors\": arrayFiltersOutput,\n      \"fruits\": ['kiwi', 'orange', 'apple', 'lemon', 'coconut'],\n      \"starWarsCharacters\": ['luke', 'leia', 'han', 'yoda']\n    };\n    var trackedKeywordsOutput = [\n      'blue',\n      'white',\n      'yellow',\n      'green',\n      'orange',\n      'kiwi',\n      'apple',\n      'lemon',\n      'coconut',\n      'Luke',\n      'Leia',\n      'Han',\n      'Yoda'\n    ];\n\n    it('should take a direct string in track parameter', function() {\n      var stream = client.streamChannels({track: stringFiltersInput});\n      stream.stop();\n      expect(stream.getChannels().default).toBeDefined();\n      expect(stream.getChannels().default).toEqual(arrayFiltersOutput);\n    });\n\n    it('should take a direct array in track parameter', function() {\n      var stream = client.streamChannels({track: arrayFiltersInput});\n      stream.stop();\n      expect(stream.getChannels().default).toBeDefined();\n      expect(stream.getChannels().default).toEqual(arrayFiltersOutput);\n    });\n\n    it('should take a channels object in track parameter', function() {\n      var stream = client.streamChannels({track: channelsInput});\n      stream.stop();\n      expect(stream.getChannels()).toBeDefined();\n      expect(stream.getChannels()).toEqual(channelsOuput);\n    });\n\n    it('should not have duplicates in tracked keywords', function() {\n      var stream = client.streamChannels({track: channelsInput});\n      stream.stop();\n      expect(stream.getTrackedKeywords()).toBeDefined();\n      expect(stream.getTrackedKeywords()).toEqual(trackedKeywordsOutput);\n    });\n\n    it('should have a regexp version of the channels - working in lower case', function() {\n      var stream = client.streamChannels({track: channelsInput});\n      stream.stop();\n      expect(stream.getChannelsKeywordsLowerCasedRegExp()).toBeDefined();\n      expect(stream.getChannelsKeywordsLowerCasedRegExp()['colors'] instanceof RegExp).toBe(true);\n      expect('this is blue and also white but not red'.match(stream.getChannelsKeywordsLowerCasedRegExp()['colors'])).toEqual(['blue','white']);\n      expect('you may like lemon and orange, in juice ?'.match(stream.getChannelsKeywordsLowerCasedRegExp()['fruits'])).toEqual(['lemon','orange']);\n      expect('Some would say that yoda is wiser than Luke'.match(stream.getChannelsKeywordsLowerCasedRegExp()['starWarsCharacters'])).toEqual(['yoda','han']);\n    });\n\n  });\n\n});","/home/travis/build/npmtest/node-npmtest-twitter-stream-channels/node_modules/twitter-stream-channels/spec/online/dummy-spec.js":"/*\n * This is where you could put online unit tests\n * For the moment, there aren't any because I've tested all what I wanted with offline version with the mocks\n * \n * I'm not so sure there should be any online unit-tests (this should be some other kind of tests)\n */\n\ndescribe(\"No online tests for the moment, not so sure there should be any or that they should be unit-tests\",function(){\n  \n});"}